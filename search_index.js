var documenterSearchIndex = {"docs":
[{"location":"#AtiyahBott.jl","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"","category":"section"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"","category":"page"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"AtiyahBott","category":"page"},{"location":"#AtiyahBott","page":"AtiyahBott.jl","title":"AtiyahBott","text":"AtiyahBott is a module containing an implementation of the Atiyah-Bott residue formula in the Julia language. The theory and the algorithm behind the package is described in the paper  \"Effective computations of the Atiyah-Bott formula\" by GiosuÃ¨ Muratore and  Csaba Schneider (https://arxiv.org/pdf/2105.11183.pdf).\n\nThe colorations (useful to speed up the code) are up to projective spaces of dimension 29. The full list is here: https://github.com/mgemath/Colorations/.\n\n\n\n\n\n","category":"module"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"In order to install the package, type:","category":"page"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"julia> using Pkg\r\njulia> Pkg.add(\"AtiyahBott\")","category":"page"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"To load the package, type:","category":"page"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"julia> using AtiyahBott","category":"page"},{"location":"#The-function-AtiyahBottFormula","page":"AtiyahBott.jl","title":"The function AtiyahBottFormula","text":"","category":"section"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"This is the main function of the package.","category":"page"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"AtiyahBottFormula(n::Int64, deg::Int64, n_marks::Int64, P, do_check::Bool = true, show_bar::Bool = true, down_col::Bool = true)","category":"page"},{"location":"#Equivariant-Classes","page":"AtiyahBott.jl","title":"Equivariant Classes","text":"","category":"section"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"Here we list all equivariant classes currently supported by the package.","category":"page"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"Hypersurface\r\nO1_i\r\nO1\r\nIncidency\r\nPsi\r\nJet\r\nContact\r\nR1\r\nEuler_inv","category":"page"},{"location":"#AtiyahBott.Hypersurface","page":"AtiyahBott.jl","title":"AtiyahBott.Hypersurface","text":"Hypersurface(b)\n\nEquivariant class of the Euler class of the bundle equal to the direct image under the forgetful map of mathrmev^*mathcalO_mathbbP^n(b). It parameterizes curves contained in a hypersurface of degree b.\n\nArguments\n\nb::Int64: the degrees of the hypersurface. Alternatively, it can be an array of integers, meaning the multiplication of the equivariant class defined by each element of the array.\n\nExample\n\nThe following Gromov-Witten invariants of Calabi-Yau threefolds\n\nbeginaligned\nint_overlineM_00(mathbbP^41)mathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^4(5))) = 2875 \nint_overlineM_00(mathbbP^52)mathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^5(3))^oplus 2) = frac4235498 \nint_overlineM_00(mathbbP^53)mathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^5(4)))cdotmathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^5(2))) = frac42269081627 \nint_overlineM_00(mathbbP^74)mathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^7(2)))^4 = 25705160 \nendaligned\n\ncan be computed as\n\njulia> P = Hypersurface(5);\njulia> AtiyahBottFormula(4,1,0,P);\nResult: 2875\njulia> P = Hypersurface([3,3]);\njulia> AtiyahBottFormula(5,2,0,P);\nResult: 423549//8\njulia> P = Hypersurface(4)*Hypersurface(2);\njulia> AtiyahBottFormula(5,3,0,P);\nResult: 422690816//27\njulia> P = Hypersurface(2)^4;\njulia> AtiyahBottFormula(7,4,0,P);\nResult: 25705160\n\nwarning: Attention!\nThe program will stop if b is not positive.\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.O1_i","page":"AtiyahBott.jl","title":"AtiyahBott.O1_i","text":"O1_i(j)\n\nEquivariant class of the pull-back of mathcalO_mathbbP^n(1) with respect to the j-th evaluation map.\n\nArguments\n\nj::Int64: the evaluation map.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_02(mathbbP^11)mathrmev_1^*mathcalO_mathbbP^1(1)cdotmathrmev_2^*mathcalO_mathbbP^1(1) = 1 \nint_overlineM_01(mathbbP^31)mathrmev_1^*mathcalO_mathbbP^2(1)^2cdotmathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^3(2))) = 4\nendaligned\n\ncan be computed as\n\njulia> P = O1_i(1)*O1_i(2);\njulia> AtiyahBottFormula(1,1,2,P);\nResult: 1\njulia> P = O1_i(1)^2*Hypersurface(2);\njulia> AtiyahBottFormula(3,1,1,P);\nResult: 4\n\nwarning: Attention!\nThe program will stop if j is not between 1 and the number of marks.\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.O1","page":"AtiyahBott.jl","title":"AtiyahBott.O1","text":"O1()\n\nEquivariant class of the pull-back of mathcalO_mathbbP^n(1) with respect to the product of all evaluation maps.\n\nThis function is equivalent to the product of the function O1_i(i) where i runs from 1 to the number of marks.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_08(mathbbP^23)prod_i=1^8mathrmev_i^*mathcalO_mathbbP^2(1)^2 = 12 \nint_overlineM_01(mathbbP^32)mathrmev_1^*mathcalO_mathbbP^3(1)^2cdotmathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^3(3))) = 81 \nendaligned\n\ncan be computed as\n\njulia> P = O1()^2;\njulia> AtiyahBottFormula(2,3,8,P);\nResult: 12\njulia> P = O1()^2*Hypersurface(3);\njulia> AtiyahBottFormula(3,2,1,P);\nResult: 81\n\nIn order to remove O1_i(j) for some j, it is enough to divide by that function.\n\nExample\n\njulia> P = O1()//O1_i(1);\n\nHere P is the product of all O1_i(j) where j runs from 2 to m.\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.Incidency","page":"AtiyahBott.jl","title":"AtiyahBott.Incidency","text":"Incidency(r)\n\nEquivariant class of the cycle parameterizing curves meeting a linear subspace of codimension r.\n\nArguments\n\nr::Int64: the codimension of the subvariety. Alternatively, it can be an array of integers, meaning the multiplication of the equivariant class defined by each element of the array.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_00(mathbbP^31)delta_*(mathrmev^*mathcalO_mathbbP^3(1)^3)^2 = 1 \nint_overlineM_00(mathbbP^31)delta_*(mathrmev^*mathcalO_mathbbP^3(1)^2)^2cdot delta_*(mathrmev^*mathcalO_mathbbP^3(1)^3) = 1 \nint_overlineM_00(mathbbP^33)delta_*(mathrmev^*mathcalO_mathbbP^3(1)^2)^2cdot mathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^3(3))) = 756 \nendaligned\n\ncan be computed as\n\njulia> P = Incidency(3)^2;\njulia> AtiyahBottFormula(3,1,0,P);\nResult: 1\njulia> P = Incidency([2,2,3]);\njulia> AtiyahBottFormula(3,1,0,P);\nResult: 1\njulia> P = Incidency([2,2])*Hypersurface(3);\njulia> AtiyahBottFormula(3,3,0,P);\nResult: 756\n\nwarning: Attention!\nThe program will stop if r is not positive.\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.Psi","page":"AtiyahBott.jl","title":"AtiyahBott.Psi","text":"Psi(a)\n\nEquivariant class of the cycle of psi-classes.\n\nArguments\n\na::Vector{Int64}: the vector of the exponents of the psi classes. It is ordered, meaning that the first element is the exponent of psi_1, the second is the exponent of psi_2, and so on.\n\nnote: Note\nThe size of a must be at most m. If it is smaller, missing exponents will be considered as zeros. If a is a number, it will be considered as the exponent of psi_1.\n\nwarning: Attention!\nThe program will stop if we have one of the following conditions:the size of a is bigger than m,\na contains a negative number.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_02(mathbbP^62)mathrmev_1^*mathcalO_mathbbP^6(1)^5cdotmathrmev_2^*mathcalO_mathbbP^6(1)^2cdotmathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^6(5)))cdotpsi_1psi_2^0 = 495000 \nint_overlineM_02(mathbbP^102)mathrmev_1^*mathcalO_mathbbP^10(1)^8cdotmathrmev_2^*mathcalO_mathbbP^10(1)^6cdotmathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^10(7)))cdotpsi_1^2 = 71804533752 \nint_overlineM_01(mathbbP^22)mathrmev_1^*mathcalO_mathbbP^2(1)^2cdotpsi_1^4 = frac18 \nint_overlineM_01(mathbbP^22)delta_*(mathrmev^*mathcalO_mathbbP^2(1)^2)^4cdotmathrmev_1^*mathcalO_mathbbP^2(1)cdot(mathrmev_1^*mathcalO_mathbbP^2(1)+psi_1) = 2 \nint_overlineM_01(mathbbP^22)mathrmev_1^*mathcalO_mathbbP^2(1)^2cdot(psi_1^3cdotmathrmev_1^*mathcalO_mathbbP^2(1)+psi_1^2cdotmathrmev_1^*mathcalO_mathbbP^2(1)^2) = frac18 \nint_overlineM_01(mathbbP^32)mathrmev_1^*mathcalO_mathbbP^2(1)cdot(psi_1^7cdotmathrmev_1^*mathcalO_mathbbP^2(1)+psi_1^6cdotmathrmev_1^*mathcalO_mathbbP^2(1)^2) = -frac516 \nendaligned\n\ncan be computed as\n\njulia> P = O1_i(1)^5*O1_i(2)^2*Hypersurface(5)*Psi([1,0]);\njulia> AtiyahBottFormula(6,2,2,P);\nResult: 495000\njulia> P = O1_i(1)^8*O1_i(2)^6*Hypersurface(7)*Psi(2);\njulia> AtiyahBottFormula(10,2,2,P);\nResult: 71804533752\njulia> P = O1()^2*Psi(4);\njulia> AtiyahBottFormula(2,2,1,P);\nResult: 1//8\njulia> P = Incidency(2)^4*O1_i(1)*(O1_i(1) + Psi(1));\njulia> AtiyahBottFormula(2,2,1,P); #number of plane conics through four points and tangent to a line\nResult: 2\njulia> P = O1()^2*(Psi(3)*O1()+Psi(2)*O1()^2);\njulia> AtiyahBottFormula(2,2,1,P);\nResult: 1//8\njulia> P = O1()*(Psi(7)*O1()+Psi(6)*O1()^2);\njulia> AtiyahBottFormula(3,2,1,P);\nResult: -5//16\n\nwarning: Psi is singleton!\nPsi cannot be multiplied by itself.julia> P = O1()^2*Psi(1)^4;                  #this is **wrong**\njulia> AtiyahBottFormula(2,2,1,P);\nWarning: more instances of Psi has been found. Type:\njulia> ?Psi\nfor support.\njulia> P = O1()^2*Psi(3)*Psi(1);             #this is **wrong**\njulia> AtiyahBottFormula(2,2,1,P);\nWarning: more instances of Psi has been found. Type:\njulia> ?Psi\nfor support.\njulia> P = O1()^2*Psi(4);\njulia> AtiyahBottFormula(2,2,1,P);\nResult: 1//8\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.Jet","page":"AtiyahBott.jl","title":"AtiyahBott.Jet","text":"Jet(p, q)\n\nEquivariant class of the jet bundle J^p of the pull back of mathcalO_mathbbP^n(q) with respect to the first psi-class.\n\nArguments\n\np::Int64: the exponent of the Jet bundle. In particular, it is a bundle of rank p+1.\nq::Int64: the degree of the line bundle that is pulled back.\n\nnote: Note\nIn order to define this bundle, the number of marks must be at least 1. You cannot multiply this bundle by the class Psi(a).\n\nExample\n\nbeginaligned\nint_overlineM_01(mathbbP^22)delta_*(mathrmev^*mathcalO_mathbbP^2(1)^2)^4cdotmathrmc_top(J^1(mathrmev_1^*mathcalO_mathbbP^2(1))) = 2 \nint_overlineM_01(mathbbP^22)delta_*(mathrmev^*mathcalO_mathbbP^2(1)^2)^4cdot(mathrmc_top(J^1(mathrmev_1^*mathcalO_mathbbP^2(1)))+mathrmev_1^*mathcalO_mathbbP^2(1)^2) = 3 \nint_overlineM_01(mathbbP^3d)fracmathrmev_1^*mathcalO_mathbbP^3(1)^2kcdotmathrmc_top(J^4d-2(mathrmev_1^*mathcalO_mathbbP^3(k))) = frac(4d-2)(d)^4 \nendaligned\n\ncan be computed as\n\njulia> P = Incidency(2)^4*Jet(1,1);\njulia> AtiyahBottFormula(2,2,1,P);\nResult: 2\njulia> P = Incidency(2)^4*(Jet(1,1)+O1()^2);\njulia> AtiyahBottFormula(2,2,1,P);\nResult: 3\njulia> d=1;k=1; #for other values of d, change this line\njulia> P = (O1()^2)//k*Jet(4*d-2,k);\njulia> AtiyahBottFormula(3,d,1,P);   #The value of this integral does not depend on k, only on d\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.Contact","page":"AtiyahBott.jl","title":"AtiyahBott.Contact","text":"Contact()\n\nEquivariant class of the Euler class of the bundle equal to the direct image under the forgetful map of mathrmev^*mathcalO_mathbbP^n(2) tensor the dualizing sheaf of the forgetful map. It parameterizes contact curves in an odd dimensional projective space.\n\nExample\n\nbeginaligned\nint_overlineM_02(mathbbP^31)mathrmev_1^*mathcalO_mathbbP^3(1)^2cdotmathrmev_2^*mathcalO_mathbbP^3(1)^3cdotmathrmc_top(delta_*(omega_deltaotimesmathrmev^*mathcalO_mathbbP^3(2))) = 1 \nendaligned\n\ncan be computed as\n\njulia> P = O1_i(1)^2*O1_i(2)^3*Contact();\njulia> AtiyahBottFormula(3,1,2,P);\nResult: 1\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.R1","page":"AtiyahBott.jl","title":"AtiyahBott.R1","text":"R1(k)\n\nThe equivariant class of the first derived functor of the pull-back of mathcalO_mathbbP^n(-k).\n\nArguments\n\nk::Int64: a positive integer.\n\nExample\n\nbeginaligned\nint_overlineM_00(mathbbP^1d)mathrmc_top(R^1delta_*(mathrmev^*mathcalO_mathbbP^3(-1)))^2 = frac1d^3 \nendaligned\n\ncan be computed as\n\njulia> d = 1; #for other values of d, change this line\njulia> P = R1(1)^2;\njulia> AtiyahBottFormula(1,d,0,P);\nResult: 1\n\nwarning: Attention!\nThe program will stop if k is not positive.\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.Euler_inv","page":"AtiyahBott.jl","title":"AtiyahBott.Euler_inv","text":"Euler_inv(g, c, w, s, m)\n\nThe inverse of the (equivariant) Euler class of the normal bundle. This function is invoked automatically.\n\nArguments\n\ng::SimpleGraph: the graph.\nc::Vector{UInt8}: the coloration.\nw::Vector{Int64}: the weights.\ns::Vector{fmpq}: the scalars.\nm::Vector{Int64}: the marks.\n\n\n\n\n\n","category":"function"},{"location":"#Other-Functions","page":"AtiyahBott.jl","title":"Other Functions","text":"","category":"section"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"dim_M\r\ncodim\r\nis_zero_cycle\r\ncheck_Data\r\nfill_Data\r\nfree_Data","category":"page"},{"location":"#AtiyahBott.dim_M","page":"AtiyahBott.jl","title":"AtiyahBott.dim_M","text":"dim_M(n, d, m)\n\nThe dimension of the moduli space of stable rational map to the projective space of dimension n, of degree d with m marks.\n\nArguments\n\nn::Int64: the dimension of the projective space.\nd::Int64: the degree of the stable maps.\nm::Int64: the number of marks.\n\nExample\n\njulia> dim_M(2,2,5)\n10\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.codim","page":"AtiyahBott.jl","title":"AtiyahBott.codim","text":"codim(n, d, m, P)\n\nThe codimension of the equivariant class P.\n\nArguments\n\nn::Int64: the dimension of the projective space.\nd::Int64: the degree of the stable maps.\nm::Int64: the number of marks.\nP: the equivariant class.\n\nExample\n\njulia> P = (g,c,w,s,m) -> Hypersurface(g,c,w,s,5);\njulia> codim(4,1,0,P)\n6\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.is_zero_cycle","page":"AtiyahBott.jl","title":"AtiyahBott.is_zero_cycle","text":"is_zero_cycle(n, d, m, P)\n\nReturn true if the equivariant class P is a 0-cycle in the moduli space, false otherwise.\n\nArguments\n\nn::Int64: the dimension of the projective space.\ndeg::Int64: the degree of the stable maps.\nn_marks::Int64: the number of marks.\nP: the equivariant class.\n\nExample\n\njulia> P = (g,c,w,s,m) -> Hypersurface(g,c,w,s,5);\njulia> is_zero_cycle(4,1,0,P)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.check_Data","page":"AtiyahBott.jl","title":"AtiyahBott.check_Data","text":"check_Data()\n\nList of all files containing the colorations in the folder Data.\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.fill_Data","page":"AtiyahBott.jl","title":"AtiyahBott.fill_Data","text":"fill_Data(n, d)\n\nDownload from internet all colorations used for computations in the moduli space with dimension n and degree d. Return true if there is no need to download any file or if all downloads go well. Otherwise, return false.\n\n\n\n\n\n","category":"function"},{"location":"#AtiyahBott.free_Data","page":"AtiyahBott.jl","title":"AtiyahBott.free_Data","text":"free_Data()\n\nDelete the folder Data.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"AtiyahBott.jl","title":"Index","text":"","category":"section"},{"location":"","page":"AtiyahBott.jl","title":"AtiyahBott.jl","text":"","category":"page"}]
}
