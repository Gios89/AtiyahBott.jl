<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AtiyahBott.jl · AtiyahBott</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>AtiyahBott</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AtiyahBott.jl</a><ul class="internal"><li><a class="tocitem" href="#The-function-AtiyahBottFormula"><span>The function AtiyahBottFormula</span></a></li><li><a class="tocitem" href="#Equivariant-Classes"><span>Equivariant Classes</span></a></li><li><a class="tocitem" href="#Other-Functions"><span>Other Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AtiyahBott.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AtiyahBott.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mgemath/AtiyahBott.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AtiyahBott.jl"><a class="docs-heading-anchor" href="#AtiyahBott.jl">AtiyahBott.jl</a><a id="AtiyahBott.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AtiyahBott.jl" title="Permalink"></a></h1><ul><li><a href="#AtiyahBott.jl">AtiyahBott.jl</a></li><li class="no-marker"><ul><li><a href="#The-function-AtiyahBottFormula">The function AtiyahBottFormula</a></li><li><a href="#Equivariant-Classes">Equivariant Classes</a></li><li><a href="#Other-Functions">Other Functions</a></li><li><a href="#Index">Index</a></li></ul></li></ul><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott" href="#AtiyahBott"><code>AtiyahBott</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>AtiyahBott</strong> is a module containing an implementation of the Atiyah-Bott residue formula in the Julia language. The theory and the algorithm behind the package is described in the paper  &quot;Effective computations of the Atiyah-Bott formula&quot; by Giosuè Muratore and  Csaba Schneider (https://arxiv.org/pdf/2105.11183.pdf).</p><p>The colorations (useful to speed up the code) are up to projective spaces of dimension 29. The full list is here: https://github.com/mgemath/Colorations/.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/AtiyahBott.jl#L1-L9">source</a></section></article><p>In order to install the package, type:</p><pre><code class="language-julia-repl hljs">julia&gt; using Pkg
julia&gt; Pkg.add(&quot;AtiyahBott&quot;)</code></pre><p>To load the package, type:</p><pre><code class="language-julia-repl hljs">julia&gt; using AtiyahBott</code></pre><h2 id="The-function-AtiyahBottFormula"><a class="docs-heading-anchor" href="#The-function-AtiyahBottFormula">The function AtiyahBottFormula</a><a id="The-function-AtiyahBottFormula-1"></a><a class="docs-heading-anchor-permalink" href="#The-function-AtiyahBottFormula" title="Permalink"></a></h2><p>This is the main function of the package.</p><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.AtiyahBottFormula" href="#AtiyahBott.AtiyahBottFormula"><code>AtiyahBott.AtiyahBottFormula</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AtiyahBottFormula(n, d, m, P; do_check, show_bar, down_col)</code></pre><p>Apply the Atiyah-Bott residue formula to the class <code>P</code>, in the moduli space of rational marked stable maps to the projective space of dimension <code>n</code> of degree <code>d</code> with <code>m</code> marks.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space, it must be between <span>$1$</span> and <span>$254$</span>.</li><li><code>d::Int64</code>: the degree of the stable maps, it must be between <span>$1$</span> and <span>$13$</span>.</li><li><code>m::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li><li><code>do_check::Bool</code>: if <code>true</code>, checks if <code>P</code> is a well defined zero cycle, and stops the computation if this is not true. If <code>false</code>, the computation may have an unexpected behaviour. By default is <code>true</code>.</li><li><code>show_bar::Bool</code>: hide the progress bar if and only if this condition is <code>false</code>. By default is <code>true</code>.</li><li><code>down_col::Bool</code>: check if all colorations needed in the computation are in the folder Data, and download them otherwise. Once downloaded, those files can be used for future computations. By default is <code>true</code>.</li></ul><p>The general construction of <code>P</code> is the following:</p><pre><code class="language-julia-repl hljs">julia&gt; P = </code></pre><p>After <code>=</code>, one has to write an expression in the equivariant classes. The expression is a combination of the equivariant classes. We compute the degree of <code>P</code> by</p><pre><code class="language-julia-repl hljs">julia&gt; AtiyahBottFormula(n,d,m,P);</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = Hypersurface(5);
julia&gt; AtiyahBottFormula(3,1,0,P);
Warning: the class is not a 0-cycle.
julia&gt; AtiyahBottFormula(4,1,0,P);
Result: 2875
julia&gt; AtiyahBottFormula(4,1,0,P,do_check = false); #skip the preliminary check on `P`
julia&gt; AtiyahBottFormula(4,1,0,P,show_bar = false); #it does not show the progress bar
julia&gt; AtiyahBottFormula(4,1,0,P,down_col = false); #it does not download the colorations, if missing</code></pre><p>The function returns an array of the same dimension of <code>P</code> (non-vectorized classes are assumed as 1-dimensional arrays). The Julia notation for accessing to array is <code>name_of_array[i]</code> where <code>i</code> is an index starting from 1.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = Incidency(2)*Hypersurface(3);
julia&gt; x = AtiyahBottFormula(3,2,0,P)[1];
Result: 81
julia&gt; x
81</code></pre><p>The class <code>P</code> supports parameters.</p><pre><code class="language-julia-repl hljs">julia&gt; P = Hypersurface(3)*(Incidency(2)//3)^(d-1);
julia&gt; d = 2;
julia&gt; AtiyahBottFormula(3,d,0,P);
Result: 27
julia&gt; d = 3;
julia&gt; AtiyahBottFormula(3,d,0,P);
Result: 84</code></pre><p>More examples are available in the support of the equivariant classes. It is enough to type <code>?</code> and then the name of the class. Currently, the supported classes are:</p><ul><li><code>O1_i</code>         (Euler class of <span>$\mathrm{ev}_i^*\mathcal{O}_{\mathbb{P}^n}(1)$</span>)</li><li><code>O1</code>           (product of all <code>O1_i</code>)</li><li><code>Psi</code>          (cycle of <span>$\psi$</span>-classes)</li><li><code>Jet</code>          (Euler class of the jet bundle <span>$J^p$</span> of <span>$\mathrm{ev}^*\mathcal{O}_{\mathbb{P}^n}(q)$</span>)</li><li><code>Hypersurface</code> (Euler class of the direct image of <span>$\mathrm{ev}^*\mathcal{O}_{\mathbb{P}^n}(b)$</span>)</li><li><code>Incidency</code>    (cycle parameterizing curves meeting a linear subspace)</li><li><code>Contact</code>      (cycle parameterizing contact curves)</li><li><code>R1</code>           (first derived functor of direct image of <span>$\mathrm{ev}^*\mathcal{O}_{\mathbb{P}^n}(-k)$</span>)</li></ul><p>To add more classes, please contact the authors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/Main.jl#L11-L80">source</a></section></article><h2 id="Equivariant-Classes"><a class="docs-heading-anchor" href="#Equivariant-Classes">Equivariant Classes</a><a id="Equivariant-Classes-1"></a><a class="docs-heading-anchor-permalink" href="#Equivariant-Classes" title="Permalink"></a></h2><p>Here we list all equivariant classes currently supported by the package.</p><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Hypersurface" href="#AtiyahBott.Hypersurface"><code>AtiyahBott.Hypersurface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Hypersurface(b)</code></pre><p>Equivariant class of the Euler class of the bundle equal to the direct image under the forgetful map of <span>$\mathrm{ev}^*\mathcal{O}_{\mathbb{P}^n}(b)$</span>. It parameterizes curves contained in a hypersurface of degree <code>b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>b::Int64</code>: the degrees of the hypersurface. Alternatively, it can be an array of integers, meaning the multiplication of the equivariant class defined by each element of the array.</li></ul><p><strong>Example</strong></p><p>The following Gromov-Witten invariants of Calabi-Yau threefolds</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,0}(\mathbb{P}^{4},1)}\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{4}}(5))) &amp;= 2875 \\
\int_{\overline{M}_{0,0}(\mathbb{P}^{5},2)}\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{5}}(3))^{\oplus 2}) &amp;= \frac{423549}{8} \\
\int_{\overline{M}_{0,0}(\mathbb{P}^{5},3)}\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{5}}(4)))\cdot\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{5}}(2))) &amp;= \frac{422690816}{27} \\
\int_{\overline{M}_{0,0}(\mathbb{P}^{7},4)}\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{7}}(2)))^4 &amp;= 25705160 \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P = Hypersurface(5);
julia&gt; AtiyahBottFormula(4,1,0,P);
Result: 2875
julia&gt; P = Hypersurface([3,3]);
julia&gt; AtiyahBottFormula(5,2,0,P);
Result: 423549//8
julia&gt; P = Hypersurface(4)*Hypersurface(2);
julia&gt; AtiyahBottFormula(5,3,0,P);
Result: 422690816//27
julia&gt; P = Hypersurface(2)^4;
julia&gt; AtiyahBottFormula(7,4,0,P);
Result: 25705160</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>b</code> is not positive.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L240-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.O1_i" href="#AtiyahBott.O1_i"><code>AtiyahBott.O1_i</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">O1_i(j)</code></pre><p>Equivariant class of the pull-back of <span>$\mathcal{O}_{\mathbb{P}^n}(1)$</span> with respect to the j-th evaluation map.</p><p><strong>Arguments</strong></p><ul><li><code>j::Int64</code>: the evaluation map.</li></ul><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,2}(\mathbb{P}^{1},1)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{1}}(1)\cdot\mathrm{ev}_{2}^{*}\mathcal{O}_{\mathbb{P}^{1}}(1) &amp;= 1 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{3},1)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}\cdot\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(2))) &amp;= 4
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P = O1_i(1)*O1_i(2);
julia&gt; AtiyahBottFormula(1,1,2,P);
Result: 1
julia&gt; P = O1_i(1)^2*Hypersurface(2);
julia&gt; AtiyahBottFormula(3,1,1,P);
Result: 4</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>j</code> is not between 1 and the number of marks.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L395-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.O1" href="#AtiyahBott.O1"><code>AtiyahBott.O1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">O1()</code></pre><p>Equivariant class of the pull-back of <span>$\mathcal{O}_{\mathbb{P}^n}(1)$</span> with respect to the product of all evaluation maps.</p><p>This function is equivalent to the product of the function <code>O1_i(i)</code> where <code>i</code> runs from 1 to the number of marks.</p><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,8}(\mathbb{P}^{2},3)}\prod_{i=1}^{8}\mathrm{ev}_{i}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^2 &amp;= 12 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{3},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^2\cdot\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(3))) &amp;= 81 \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P = O1()^2;
julia&gt; AtiyahBottFormula(2,3,8,P);
Result: 12
julia&gt; P = O1()^2*Hypersurface(3);
julia&gt; AtiyahBottFormula(3,2,1,P);
Result: 81</code></pre><p>In order to remove <code>O1_i(j)</code> for some <code>j</code>, it is enough to divide by that function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = O1()//O1_i(1);</code></pre><p>Here <code>P</code> is the product of all <code>O1_i(j)</code> where <code>j</code> runs from 2 to <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L435-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Incidency" href="#AtiyahBott.Incidency"><code>AtiyahBott.Incidency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Incidency(r)</code></pre><p>Equivariant class of the cycle parameterizing curves meeting a linear subspace of codimension <code>r</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r::Int64</code>: the codimension of the subvariety. Alternatively, it can be an array of integers, meaning the multiplication of the equivariant class defined by each element of the array.</li></ul><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,0}(\mathbb{P}^{3},1)}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{3})^{2} &amp;= 1 \\
\int_{\overline{M}_{0,0}(\mathbb{P}^{3},1)}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{2})^{2}\cdot \delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{3}) &amp;= 1 \\
\int_{\overline{M}_{0,0}(\mathbb{P}^{3},3)}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{2})^{2}\cdot \mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(3))) &amp;= 756 \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P = Incidency(3)^2;
julia&gt; AtiyahBottFormula(3,1,0,P);
Result: 1
julia&gt; P = Incidency([2,2,3]);
julia&gt; AtiyahBottFormula(3,1,0,P);
Result: 1
julia&gt; P = Incidency([2,2])*Hypersurface(3);
julia&gt; AtiyahBottFormula(3,3,0,P);
Result: 756</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>r</code> is not positive.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L159-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Psi" href="#AtiyahBott.Psi"><code>AtiyahBott.Psi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Psi(a)</code></pre><p>Equivariant class of the cycle of <span>$\psi$</span>-classes.</p><p><strong>Arguments</strong></p><ul><li><code>a::Vector{Int64}</code>: the vector of the exponents of the <span>$\psi$</span> classes. It is ordered, meaning that the first element is the exponent of <span>$\psi_1$</span>, the second is the exponent of <span>$\psi_2$</span>, and so on.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The size of <code>a</code> must be at most <code>m</code>. If it is smaller, missing exponents will be considered as zeros. If <code>a</code> is a number, it will be considered as the exponent of <span>$\psi_1$</span>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if we have one of the following conditions:</p><ul><li>the size of <code>a</code> is bigger than <code>m</code>,</li><li><code>a</code> contains a negative number.</li></ul></div></div><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,2}(\mathbb{P}^{6},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{6}}(1)^{5}\cdot\mathrm{ev}_{2}^{*}\mathcal{O}_{\mathbb{P}^{6}}(1)^{2}\cdot\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{6}}(5)))\cdot\psi_{1}\psi_{2}^{0} &amp;= 495000 \\
\int_{\overline{M}_{0,2}(\mathbb{P}^{10},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{10}}(1)^{8}\cdot\mathrm{ev}_{2}^{*}\mathcal{O}_{\mathbb{P}^{10}}(1)^{6}\cdot\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{10}}(7)))\cdot\psi_{1}^{2} &amp;= 71804533752 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{2},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}\cdot\psi_{1}^{4} &amp;= \frac{1}{8} \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{2},2)}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2})^{4}\cdot\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)\cdot(\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)+\psi_{1}) &amp;= 2 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{2},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}\cdot(\psi_{1}^{3}\cdot\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)+\psi_{1}^{2}\cdot\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}) &amp;= \frac{1}{8} \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{3},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)\cdot(\psi_{1}^{7}\cdot\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)+\psi_{1}^{6}\cdot\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}) &amp;= -\frac{5}{16} \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P = O1_i(1)^5*O1_i(2)^2*Hypersurface(5)*Psi([1,0]);
julia&gt; AtiyahBottFormula(6,2,2,P);
Result: 495000
julia&gt; P = O1_i(1)^8*O1_i(2)^6*Hypersurface(7)*Psi(2);
julia&gt; AtiyahBottFormula(10,2,2,P);
Result: 71804533752
julia&gt; P = O1()^2*Psi(4);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 1//8
julia&gt; P = Incidency(2)^4*O1_i(1)*(O1_i(1) + Psi(1));
julia&gt; AtiyahBottFormula(2,2,1,P); #number of plane conics through four points and tangent to a line
Result: 2
julia&gt; P = O1()^2*(Psi(3)*O1()+Psi(2)*O1()^2);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 1//8
julia&gt; P = O1()*(Psi(7)*O1()+Psi(6)*O1()^2);
julia&gt; AtiyahBottFormula(3,2,1,P);
Result: -5//16</code></pre><div class="admonition is-warning"><header class="admonition-header">Psi is singleton!</header><div class="admonition-body"><p><code>Psi</code> cannot be multiplied by itself.</p><pre><code class="language-julia-repl hljs">julia&gt; P = O1()^2*Psi(1)^4;                  #this is **wrong**
julia&gt; AtiyahBottFormula(2,2,1,P);
Warning: more instances of Psi has been found. Type:
julia&gt; ?Psi
for support.
julia&gt; P = O1()^2*Psi(3)*Psi(1);             #this is **wrong**
julia&gt; AtiyahBottFormula(2,2,1,P);
Warning: more instances of Psi has been found. Type:
julia&gt; ?Psi
for support.
julia&gt; P = O1()^2*Psi(4);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 1//8</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L553-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Jet" href="#AtiyahBott.Jet"><code>AtiyahBott.Jet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Jet(p, q)</code></pre><p>Equivariant class of the jet bundle <span>$J^p$</span> of the pull back of <span>$\mathcal{O}_{\mathbb{P}^n}(q)$</span> with respect to the first <span>$\psi$</span>-class.</p><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: the exponent of the Jet bundle. In particular, it is a bundle of rank p+1.</li><li><code>q::Int64</code>: the degree of the line bundle that is pulled back.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In order to define this bundle, the number of marks must be at least 1. You cannot multiply this bundle by the class <code>Psi(a)</code>.</p></div></div><p><strong>Example</strong></p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,1}(\mathbb{P}^{2},2)}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2})^{4}\cdot\mathrm{c_{top}}(J^{1}(\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1))) &amp;= 2 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{2},2)}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2})^{4}\cdot(\mathrm{c_{top}}(J^{1}(\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)))+\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}) &amp;= 3 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{3},d)}\frac{\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{2}}{k}\cdot\mathrm{c_{top}}(J^{4d-2}(\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{3}}(k))) &amp;= \frac{(4d-2)!}{(d!)^{4}} \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P = Incidency(2)^4*Jet(1,1);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 2
julia&gt; P = Incidency(2)^4*(Jet(1,1)+O1()^2);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 3
julia&gt; d=1;k=1; #for other values of d, change this line
julia&gt; P = (O1()^2)//k*Jet(4*d-2,k);
julia&gt; AtiyahBottFormula(3,d,1,P);   #The value of this integral does not depend on k, only on d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L692-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Contact" href="#AtiyahBott.Contact"><code>AtiyahBott.Contact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Contact()</code></pre><p>Equivariant class of the Euler class of the bundle equal to the direct image under the forgetful map of <span>$\mathrm{ev}^*\mathcal{O}_{\mathbb{P}^n}(2)$</span> tensor the dualizing sheaf of the forgetful map. It parameterizes contact curves in an odd dimensional projective space.</p><p><strong>Example</strong></p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,2}(\mathbb{P}^{3},1)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{2}\cdot\mathrm{ev}_{2}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{3}\cdot\mathrm{c_{top}}(\delta_{*}(\omega_{\delta}\otimes\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(2))) &amp;= 1 \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P = O1_i(1)^2*O1_i(2)^3*Contact();
julia&gt; AtiyahBottFormula(3,1,2,P);
Result: 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L335-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.R1" href="#AtiyahBott.R1"><code>AtiyahBott.R1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R1(k)</code></pre><p>The equivariant class of the first derived functor of the pull-back of <span>$\mathcal{O}_{\mathbb{P}^n}(-k)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>k::Int64</code>: a positive integer.</li></ul><p><strong>Example</strong></p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,0}(\mathbb{P}^{1},d)}\mathrm{c_{top}}(R^{1}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(-1)))^2 &amp;= \frac{1}{d^3} \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; d = 1; #for other values of d, change this line
julia&gt; P = R1(1)^2;
julia&gt; AtiyahBottFormula(1,d,0,P);
Result: 1</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>k</code> is not positive.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L486-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Euler_inv" href="#AtiyahBott.Euler_inv"><code>AtiyahBott.Euler_inv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Euler_inv(g, c, w, s, m)</code></pre><p>The inverse of the (equivariant) Euler class of the normal bundle. This function is invoked automatically.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Vector{fmpq}</code>: the scalars.</li><li><code>m::Vector{Int64}</code>: the marks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/EquivariantClasses.jl#L752-L763">source</a></section></article><h2 id="Other-Functions"><a class="docs-heading-anchor" href="#Other-Functions">Other Functions</a><a id="Other-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.dim_M" href="#AtiyahBott.dim_M"><code>AtiyahBott.dim_M</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dim_M(n, d, m)</code></pre><p>The dimension of the moduli space of stable rational map to the projective space of dimension <code>n</code>, of degree <code>d</code> with <code>m</code> marks.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space.</li><li><code>d::Int64</code>: the degree of the stable maps.</li><li><code>m::Int64</code>: the number of marks.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dim_M(2,2,5)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/Checks.jl#L50-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.codim" href="#AtiyahBott.codim"><code>AtiyahBott.codim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">codim(n, d, m, P)</code></pre><p>The codimension of the equivariant class <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space.</li><li><code>d::Int64</code>: the degree of the stable maps.</li><li><code>m::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,5);
julia&gt; codim(4,1,0,P)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/Checks.jl#L71-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.is_zero_cycle" href="#AtiyahBott.is_zero_cycle"><code>AtiyahBott.is_zero_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_zero_cycle(n, d, m, P)</code></pre><p>Return <code>true</code> if the equivariant class <code>P</code> is a 0-cycle in the moduli space, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space.</li><li><code>deg::Int64</code>: the degree of the stable maps.</li><li><code>n_marks::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,5);
julia&gt; is_zero_cycle(4,1,0,P)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/Checks.jl#L93-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.check_Data" href="#AtiyahBott.check_Data"><code>AtiyahBott.check_Data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_Data()</code></pre><p>List of all files containing the colorations in the folder Data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/Checks.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.fill_Data" href="#AtiyahBott.fill_Data"><code>AtiyahBott.fill_Data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fill_Data(n, d)</code></pre><p>Download from internet all colorations used for computations in the moduli space with dimension <code>n</code> and degree <code>d</code>. Return <code>true</code> if there is no need to download any file or if all downloads go well. Otherwise, return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/Checks.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.free_Data" href="#AtiyahBott.free_Data"><code>AtiyahBott.free_Data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">free_Data()</code></pre><p>Delete the folder Data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/1f5d535daaa32bcb31f8393665571604e3a944e0/src/Checks.jl#L274-L278">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AtiyahBott"><code>AtiyahBott</code></a></li><li><a href="#AtiyahBott.AtiyahBottFormula"><code>AtiyahBott.AtiyahBottFormula</code></a></li><li><a href="#AtiyahBott.Contact"><code>AtiyahBott.Contact</code></a></li><li><a href="#AtiyahBott.Euler_inv"><code>AtiyahBott.Euler_inv</code></a></li><li><a href="#AtiyahBott.Hypersurface"><code>AtiyahBott.Hypersurface</code></a></li><li><a href="#AtiyahBott.Incidency"><code>AtiyahBott.Incidency</code></a></li><li><a href="#AtiyahBott.Jet"><code>AtiyahBott.Jet</code></a></li><li><a href="#AtiyahBott.O1"><code>AtiyahBott.O1</code></a></li><li><a href="#AtiyahBott.O1_i"><code>AtiyahBott.O1_i</code></a></li><li><a href="#AtiyahBott.Psi"><code>AtiyahBott.Psi</code></a></li><li><a href="#AtiyahBott.R1"><code>AtiyahBott.R1</code></a></li><li><a href="#AtiyahBott.check_Data"><code>AtiyahBott.check_Data</code></a></li><li><a href="#AtiyahBott.codim"><code>AtiyahBott.codim</code></a></li><li><a href="#AtiyahBott.dim_M"><code>AtiyahBott.dim_M</code></a></li><li><a href="#AtiyahBott.fill_Data"><code>AtiyahBott.fill_Data</code></a></li><li><a href="#AtiyahBott.free_Data"><code>AtiyahBott.free_Data</code></a></li><li><a href="#AtiyahBott.is_zero_cycle"><code>AtiyahBott.is_zero_cycle</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 13 February 2022 20:40">Sunday 13 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
