<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AtiyahBott.jl · AtiyahBott</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>AtiyahBott</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AtiyahBott.jl</a><ul class="internal"><li><a class="tocitem" href="#The-function-AtiyahBottFormula"><span>The function AtiyahBottFormula</span></a></li><li><a class="tocitem" href="#Equivariant-Classes"><span>Equivariant Classes</span></a></li><li><a class="tocitem" href="#Other-Functions"><span>Other Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AtiyahBott.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AtiyahBott.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mgemath/AtiyahBott.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AtiyahBott.jl"><a class="docs-heading-anchor" href="#AtiyahBott.jl">AtiyahBott.jl</a><a id="AtiyahBott.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AtiyahBott.jl" title="Permalink"></a></h1><ul><li><a href="#AtiyahBott.jl">AtiyahBott.jl</a></li><ul><li><a href="#The-function-AtiyahBottFormula">The function AtiyahBottFormula</a></li><li><a href="#Equivariant-Classes">Equivariant Classes</a></li><li><a href="#Other-Functions">Other Functions</a></li><li><a href="#Index">Index</a></li></ul></ul><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott" href="#AtiyahBott"><code>AtiyahBott</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>AtiyahBott</strong> is a module containing an implementation of the Atiyah-Bott residue  formula in the Julia language. The theory behind the package is described in the paper  &quot;Effective computations of the Atiyah-Bott formula&quot; by Giosuè Muratore and  Csaba Schneider (https://arxiv.org/pdf/2105.11183.pdf). The degree of the curves of the moduli space must be at most 13. The projective space must be at most of dimension 254. The colorations (useful to speed up the code) are up to projective spaces of dimension 29. The full list is here: https://github.com/mgemath/Colorations/.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/AtiyahBott.jl#L1-L10">source</a></section></article><h2 id="The-function-AtiyahBottFormula"><a class="docs-heading-anchor" href="#The-function-AtiyahBottFormula">The function AtiyahBottFormula</a><a id="The-function-AtiyahBottFormula-1"></a><a class="docs-heading-anchor-permalink" href="#The-function-AtiyahBottFormula" title="Permalink"></a></h2><p>This is the main function of the package.</p><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.AtiyahBottFormula" href="#AtiyahBott.AtiyahBottFormula"><code>AtiyahBott.AtiyahBottFormula</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AtiyahBottFormula(n, d, m, P, do_check, show_bar, down_col)</code></pre><p>Apply the Atiyah-Bott residue formula to the class <code>P</code>, in the moduli space of rational marked stable maps to the projective space of dimension <code>n</code> of degree <code>d</code> with <code>m</code> marks.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space, it must be between 1 and 254.</li><li><code>d::Int64</code>: the degree of the stable maps, it must be between 1 and 13.</li><li><code>m::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li><li><code>do_check::Bool</code>: if <code>true</code>, checks if <code>P</code> is a well defined zero cycle, and stops the computation if this is not true. If <code>false</code>, the computation may have an unexpected behaviour. By default is <code>true</code>.</li><li><code>show_bar::Bool</code>: hide the progress bar if and only if this condition is <code>false</code>. By default is <code>true</code>.</li><li><code>down_col::Bool</code>: check if all colorations needed in the computation are in the folder Data, and download them otherwise. Once downloaded, those files can be used for future computations. By default is <code>true</code>.</li></ul><p>The general construction of <code>P</code> is the following:</p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt;</code></pre><p>After <code>-&gt;</code>, one has to write an expression in the equivariant classes. All such equivariant classes are functions starting with <code>(g,c,w,s)</code> or <code>(g,c,w,s,m)</code>. At the end, they can have more arguments. The expression is a polynomial combination of the equivariant classes. We compute the degree of <code>P</code> by</p><pre><code class="language-julia-repl hljs">julia&gt; AtiyahBottFormula(n,d,m,P);</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,5);
julia&gt; AtiyahBottFormula(3,1,0,P);
Warning: the class is not a 0-cycle.
julia&gt; AtiyahBottFormula(4,1,0,P);
Result: 2875//1
julia&gt; AtiyahBottFormula(4,1,0,P,false);             #same as before, but without the preliminary check on `P`
julia&gt; AtiyahBottFormula(4,1,0,P,false,false);       #same as before, but without showing the progress bar
julia&gt; AtiyahBottFormula(4,1,0,P,false,false,false); #same as before, but without checking for the colorations</code></pre><p>The function returns an array of the same dimension of <code>P</code> (non-vectorized classes are assumed as 1-dimensional arrays). The Julia notation for accessing to array is <code>name_of_array[i]</code> where <code>i</code> is an index starting from 1.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Incidency(g,c,w,s,2)*Hypersurface(g,c,w,s,3);
julia&gt; x = AtiyahBottFormula(3,2,0,P)[1];
Result: 81//1
julia&gt; x
81//1</code></pre><p>The class <code>P</code> supports parameters.</p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,3)*(Incidency(g,c,w,s,2)//3)^(d-1);
julia&gt; d = 2;
julia&gt; AtiyahBottFormula(3,d,0,P);
Result: 27//1
julia&gt; d = 3;
julia&gt; AtiyahBottFormula(3,d,0,P);
Result: 84//1</code></pre><p>More examples are available in the support of the equivariant classes. It is enough to type <code>?</code> and then the name of the class. Currently, the supported classes are:</p><ul><li><code>O1_i</code>         (Euler class of <span>$ev^*O(1)$</span>, where <span>$ev$</span> is a specific evaluation map)</li><li><code>O1</code>           (product of all <code>O1_i</code>)</li><li><code>Psi</code>          (cycle of <span>$psi$</span>-classes)</li><li><code>Jet</code>          (Euler class of the jet bundle <span>$J^p$</span> of <span>$ev^*O(q)$</span>)</li><li><code>Hypersurface</code> (Euler class of the direct image of <span>$ev^*O(b)$</span>)</li><li><code>Incidency</code>    (cycle parameterizing curves meeting a linear subspace)</li><li><code>Contact</code>      (cycle parameterizing contact curves)</li><li><code>R1</code>           (first derived functor of direct image of <span>$ev^*O(-k)$</span>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/Main.jl#L91-L158">source</a></section></article><h2 id="Equivariant-Classes"><a class="docs-heading-anchor" href="#Equivariant-Classes">Equivariant Classes</a><a id="Equivariant-Classes-1"></a><a class="docs-heading-anchor-permalink" href="#Equivariant-Classes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.O1_i" href="#AtiyahBott.O1_i"><code>AtiyahBott.O1_i</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Equivariant class of the pull-back of O(1) with respect to the i-th evaluation map.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li><li><code>m::marks</code>: the marks.</li><li><code>i::Int64</code>: the evaluation map.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; O1_i(g,c,w,s,m,1)*O1_i(g,c,w,s,m,2);
julia&gt; AtiyahBottFormula(2,1,2,P);
Result: 1//1
julia&gt; P = (g,c,w,s,m) -&gt; O1_i(g,c,w,s,m,1)^2*Hypersurface(g,c,w,s,2);
julia&gt; AtiyahBottFormula(3,1,1,P);
Result: 4//1</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>i</code> is not between 1 and the number of marks.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L169-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.O1" href="#AtiyahBott.O1"><code>AtiyahBott.O1</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Equivariant class of the pull-back of O(1) with respect to the product of all evaluation maps.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li><li><code>m::marks</code>: the marks.</li></ul><p>This function is equivalent to the product of the function <code>O1_i(g,c,w,s,m,i)</code> where <code>i</code> runs from 1 to the number of marks.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m);
julia&gt; AtiyahBottFormula(2,3,8,P);
Result: 12//1
julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)^2*Hypersurface(g,c,w,s,3);
julia&gt; AtiyahBottFormula(3,2,1,P);
Result: 81//1</code></pre><p>In order to remove <code>O1_i(g,c,w,s,m,i)</code> for some <code>i</code>, it is enough to divide by that function.     # Example</p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)//O1_i(g,c,w,s,m,1);</code></pre><p>Here <code>P</code> is the product of all <code>O1_i(g,c,w,s,m,i)</code> where <code>i</code> runs from 2 to <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L201-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Psi" href="#AtiyahBott.Psi"><code>AtiyahBott.Psi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Equivariant class of the cycle of <span>$psi$</span>-classes.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li><li><code>m::marks</code>: the marks.</li><li><code>a::Vector{Int64}</code>: the vector of the exponents of the psi classes. It is ordered, meaning that the first element is the exponent of <span>$psi_1$</span>, the second is the exponent of <span>$psi_2$</span>, and so on.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The size of <code>a</code> must be at most <code>m</code>. If it is smaller, missing exponents will be considered as zeros. If <code>a</code> is a number, it will be considered as the exponent of <span>$psi_1$</span>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if we have one of the following conditions:</p><ul><li>the size of <code>a</code> is bigger than <code>m</code>,</li><li><code>a</code> contains a negative number.</li></ul></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; O1_i(g,c,w,s,m,1)^5*O1_i(g,c,w,s,m,2)^2*Hypersurface(g,c,w,s,5)*Psi(g,c,w,s,m,[1,0]);
julia&gt; AtiyahBottFormula(6,2,2,P);
Result: 495000//1
julia&gt; P = (g,c,w,s,m) -&gt; O1_i(g,c,w,s,m,1)^8*O1_i(g,c,w,s,m,2)^6*Hypersurface(g,c,w,s,7)*Psi(g,c,w,s,m,2);
julia&gt; AtiyahBottFormula(10,2,2,P);
Result: 71804533752//1
julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)^2*Psi(g,c,w,s,m,4);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 1//8
julia&gt; P = (g,c,w,s,m) -&gt; Incidency(g,c,w,s,2)^4*O1_i(g,c,w,s,m,1)*(O1_i(g,c,w,s,m,1) + Psi(g,c,w,s,m,1))
julia&gt; AtiyahBottFormula(2,2,1,P); #number of plane conics through four points and tangent to a line
Result: 2</code></pre><div class="admonition is-warning"><header class="admonition-header">Psi is singleton!</header><div class="admonition-body"><p><code>Psi</code> cannot be multiplied by itself.</p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)^2*Psi(g,c,w,s,m,1)^4;                  #this is **wrong**
julia&gt; AtiyahBottFormula(2,2,1,P);
Warning: more instances of Psi has been found. Type:
julia&gt; ?Psi
for support.
julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)^2*Psi(g,c,w,s,m,3)*Psi(g,c,w,s,m,1);   #this is **wrong**
julia&gt; AtiyahBottFormula(2,2,1,P);
Warning: more instances of Psi has been found. Type:
julia&gt; ?Psi
for support.
julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)^2*Psi(g,c,w,s,m,4);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 1//8
julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)^2*(Psi(g,c,w,s,m,3)*O1(g,c,w,s,m)+Psi(g,c,w,s,m,2)*O1(g,c,w,s,m)^2);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 1//8
julia&gt; P = (g,c,w,s,m) -&gt; O1(g,c,w,s,m)*(Psi(g,c,w,s,m,7)*O1(g,c,w,s,m)+Psi(g,c,w,s,m,6)*O1(g,c,w,s,m)^2);
julia&gt; AtiyahBottFormula(3,2,1,P);
Result: -5//16</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L283-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Jet" href="#AtiyahBott.Jet"><code>AtiyahBott.Jet</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Equivariant class of the jet bundle J^p of the pull back of O(q) with respect to the first <span>$psi$</span>-class.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li><li><code>m::marks</code>: the marks.</li><li><code>p::Int64</code>: the exponent of the Jet bundle. In particular, it is a bundle of rank p+1.</li><li><code>q::Int64</code>: the degree of the line bundle that is pulled back.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In order to define this bundle, the number of marks must be at least 1. You cannot multiply this bundle by the class <span>$Psi$</span>.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Incidency(g,c,w,s,2)^4*Jet(g,c,w,s,m,1,1);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 2//1
julia&gt; P = (g,c,w,s,m) -&gt; Incidency(g,c,w,s,2)^4*(Jet(g,c,w,s,m,1,1)+O1(g,c,w,s,m)^2);
julia&gt; AtiyahBottFormula(2,2,1,P);
Result: 3//1
julia&gt; P = (g,c,w,s,m) -&gt; (O1(g,c,w,s,m)^2)//k*Jet(g,c,w,s,m,4*d-2,k);
julia&gt; d=1;k=1;AtiyahBottFormula(3,d,1,P);   #The value of this integral does not depend on k, only on d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L399-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Hypersurface" href="#AtiyahBott.Hypersurface"><code>AtiyahBott.Hypersurface</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Equivariant class of the Euler class of the bundle equal to the direct image under the forgetful map of ev^*O(b). It parameterizes curves contained in a hypersurface of degree <code>b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li><li><code>b::Int64</code>: the degrees of the hypersurface. Alternatively, it can be an array of integers, meaning the multiplication of the equivariant class defined by each element of the array.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,5);
julia&gt; AtiyahBottFormula(4,1,0,P);
Result: 2875//1
julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,[3,3]);
julia&gt; AtiyahBottFormula(5,2,0,P);
Result: 423549//8
julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,4)*Hypersurface(g,c,w,s,2);
julia&gt; AtiyahBottFormula(5,3,0,P);
Result: 422690816//27
julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,2)^4;
julia&gt; AtiyahBottFormula(7,4,0,P);
Result: 25705160//1</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>b</code> is not positive.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L69-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Incidency" href="#AtiyahBott.Incidency"><code>AtiyahBott.Incidency</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Equivariant class of the cycle parameterizing curves meeting a linear subspace of codimension <code>r</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li><li><code>r::Int64</code>: the codimension of the subvariety. Alternatively, it can be an array of integers, meaning the multiplication of the equivariant class defined by each element of the array.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Incidency(g,c,w,s,3)^2;
julia&gt; AtiyahBottFormula(3,1,0,P);
Result: 1//1
julia&gt; P = (g,c,w,s,m) -&gt; Incidency(g,c,w,s,[2,2,3]);
julia&gt; AtiyahBottFormula(3,1,0,P);
Result: 1//1
julia&gt; P = (g,c,w,s,m) -&gt; Incidency(g,c,w,s,[2,2])*Hypersurface(g,c,w,s,3);
julia&gt; AtiyahBottFormula(3,3,0,P);
Result: 756//1</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>r</code> is not positive.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L13-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.Contact" href="#AtiyahBott.Contact"><code>AtiyahBott.Contact</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Equivariant class of the Euler class of the bundle equal to the direct image under the forgetful map of: ev^*O(2) tensor the dualizing sheaf of the forgetful map. It parameterizes contact curves in an odd dimensional projective space.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; O1_i(g,c,w,s,m,1)^2*O1_i(g,c,w,s,m,2)^3*Contact(g,c,w,s);
julia&gt; AtiyahBottFormula(3,1,2,P);
Result: 1//1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L131-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.R1" href="#AtiyahBott.R1"><code>AtiyahBott.R1</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The equivariant class of the first derived functor of the pull-back of O(-k).</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: the graph.</li><li><code>c::Vector{UInt8}</code>: the coloration.</li><li><code>w::Vector{Int64}</code>: the weights.</li><li><code>s::Rational{BigInt}</code>: the scalars.</li><li><code>k::Int64</code>: a positive integer.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; R1(g,c,w,s,1)^2;
julia&gt; AtiyahBottFormula(1,3,0,P);
Result: 1//27</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>k</code> is not positive.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/EquivariantClasses.jl#L241-L260">source</a></section></article><h2 id="Other-Functions"><a class="docs-heading-anchor" href="#Other-Functions">Other Functions</a><a id="Other-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.dim_M" href="#AtiyahBott.dim_M"><code>AtiyahBott.dim_M</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dim_M(n, d, m)</code></pre><p>The dimension of the moduli space of stable rational map to the projective space of dimension <code>n</code>, of degree <code>d</code> with <code>m</code> marks.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space.</li><li><code>d::Int64</code>: the degree of the stable maps.</li><li><code>m::Int64</code>: the number of marks.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dim_M(2,2,5)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/Checks.jl#L49-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.codim" href="#AtiyahBott.codim"><code>AtiyahBott.codim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">codim(n, d, m, P)</code></pre><p>The codimension of the equivariant class <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space.</li><li><code>d::Int64</code>: the degree of the stable maps.</li><li><code>m::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,5);
julia&gt; codim(4,1,0,P)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/Checks.jl#L70-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.is_zero_cycle" href="#AtiyahBott.is_zero_cycle"><code>AtiyahBott.is_zero_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_zero_cycle(n, d, m, P)</code></pre><p>Return <code>true</code> if the equivariant class <code>P</code> is a 0-cycle in the moduli space, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: the dimension of the projective space.</li><li><code>deg::Int64</code>: the degree of the stable maps.</li><li><code>n_marks::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = (g,c,w,s,m) -&gt; Hypersurface(g,c,w,s,5);
julia&gt; is_zero_cycle(4,1,0,P)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/Checks.jl#L92-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.check_Data" href="#AtiyahBott.check_Data"><code>AtiyahBott.check_Data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_Data()</code></pre><p>List of all files containing the colorations in the folder Data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/Checks.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.fill_Data" href="#AtiyahBott.fill_Data"><code>AtiyahBott.fill_Data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fill_Data(n, d)</code></pre><p>Download from internet all colorations used for computations in the moduli space of with relative n and d. Return <code>true</code> if there is no need to download any file or if all downloads go well. Otherwise, return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/Checks.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtiyahBott.AtiyahBottFormulaForGraph" href="#AtiyahBott.AtiyahBottFormulaForGraph"><code>AtiyahBott.AtiyahBottFormulaForGraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AtiyahBottFormulaForGraph(g, pruf_str, aut, n, deg, n_marks, P, s)</code></pre><p>Apply the Atiyah-Bott formula to all colorations of a specific graph. It is useful for splitting the computation in multiple parts, to be computed in single threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/AtiyahBott.jl/blob/bc8a95eb43c20d4c01c5030d1d785bacf5adf82c/src/Main.jl#L25-L29">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AtiyahBott"><code>AtiyahBott</code></a></li><li><a href="#AtiyahBott.AtiyahBottFormula"><code>AtiyahBott.AtiyahBottFormula</code></a></li><li><a href="#AtiyahBott.AtiyahBottFormulaForGraph"><code>AtiyahBott.AtiyahBottFormulaForGraph</code></a></li><li><a href="#AtiyahBott.Contact"><code>AtiyahBott.Contact</code></a></li><li><a href="#AtiyahBott.Hypersurface"><code>AtiyahBott.Hypersurface</code></a></li><li><a href="#AtiyahBott.Incidency"><code>AtiyahBott.Incidency</code></a></li><li><a href="#AtiyahBott.Jet"><code>AtiyahBott.Jet</code></a></li><li><a href="#AtiyahBott.O1"><code>AtiyahBott.O1</code></a></li><li><a href="#AtiyahBott.O1_i"><code>AtiyahBott.O1_i</code></a></li><li><a href="#AtiyahBott.Psi"><code>AtiyahBott.Psi</code></a></li><li><a href="#AtiyahBott.R1"><code>AtiyahBott.R1</code></a></li><li><a href="#AtiyahBott.check_Data"><code>AtiyahBott.check_Data</code></a></li><li><a href="#AtiyahBott.codim"><code>AtiyahBott.codim</code></a></li><li><a href="#AtiyahBott.dim_M"><code>AtiyahBott.dim_M</code></a></li><li><a href="#AtiyahBott.fill_Data"><code>AtiyahBott.fill_Data</code></a></li><li><a href="#AtiyahBott.is_zero_cycle"><code>AtiyahBott.is_zero_cycle</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Thursday 29 July 2021 13:22">Thursday 29 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
